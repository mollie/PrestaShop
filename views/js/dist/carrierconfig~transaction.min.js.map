{"version":3,"sources":["webpack://MollieModule.[name]/./node_modules/redux-react-hook/dist/index.es.js","webpack://MollieModule.[name]/./src/shared/components/LoadingDots.tsx"],"names":["BounceAnimation","keyframes","DotWrapper","styled","div","Dot","props","delay","LoadingDots"],"mappings":";;;;;;;;;;;;;;;;;;;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAyG;;AAEzG;AACA;AACA,+DAA+D;AAC/D;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA,UAAU,gBAAgB,sCAAsC,iBAAiB,EAAE;AACnF,yBAAyB,uDAAuD;AAChF;AACA;;AAEA;AACA;AACA,mBAAmB,sBAAsB;AACzC;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,mBAAmB,kBAAkB;AACrC;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA,gEAAgE,qDAAe,GAAG,+CAAS;AAC3F;AACA;AACA;AACA;AACA;AACA;AACA;AACA,CAAC;AACD;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,uBAAuB,2DAAa;AACpC;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,oBAAoB,wDAAU;AAC9B;AACA;AACA;AACA;AACA;AACA;AACA,+BAA+B,qDAAO,cAAc,mCAAmC,EAAE;AACzF;AACA;AACA;AACA;AACA;AACA;AACA,iBAAiB,sDAAQ;AACzB;AACA;AACA,2BAA2B,oDAAM;AACjC,kCAAkC,oDAAM;AACxC;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,SAAS;AACT;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,SAAS;AACT;AACA;AACA;AACA,oBAAoB,wDAAU;AAC9B;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;;AAE6D;AAC7D;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;ACjMA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AAEA,IAAMA,eAAe,GAAGC,mEAAH,mBAArB;AAMA,IAAMC,UAAU,GAAGC,yDAAM,CAACC,GAAV,oBAAhB;AAUA,IAAMC,GAAG,GAAGF,yDAAM,CAACC,GAAV,qBAQMJ,eARN,EASY,UAACM,KAAD;AAAA,SAAsBA,KAAK,CAACC,KAA5B;AAAA,CATZ,CAAT;;AAYA,SAASC,WAAT,GAAyC;AACvC,sBACE,2DAAC,UAAD,qBACE,2DAAC,GAAD;AAAK,SAAK,EAAC;AAAX,IADF,eAEE,2DAAC,GAAD;AAAK,SAAK,EAAC;AAAX,IAFF,eAGE,2DAAC,GAAD;AAAK,SAAK,EAAC;AAAX,IAHF,CADF;AAOD;;AAEcA,0EAAf,E","file":"carrierconfig~transaction.min.js","sourcesContent":["import { createContext, useContext, useMemo, useState, useRef, useLayoutEffect, useEffect } from 'react';\n\n/*! *****************************************************************************\r\nCopyright (c) Microsoft Corporation. All rights reserved.\r\nLicensed under the Apache License, Version 2.0 (the \"License\"); you may not use\r\nthis file except in compliance with the License. You may obtain a copy of the\r\nLicense at http://www.apache.org/licenses/LICENSE-2.0\r\n\r\nTHIS CODE IS PROVIDED ON AN *AS IS* BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY\r\nKIND, EITHER EXPRESS OR IMPLIED, INCLUDING WITHOUT LIMITATION ANY IMPLIED\r\nWARRANTIES OR CONDITIONS OF TITLE, FITNESS FOR A PARTICULAR PURPOSE,\r\nMERCHANTABLITY OR NON-INFRINGEMENT.\r\n\r\nSee the Apache Version 2.0 License for specific language governing permissions\r\nand limitations under the License.\r\n***************************************************************************** */\r\n/* global Reflect, Promise */\r\n\r\nvar extendStatics = function(d, b) {\r\n    extendStatics = Object.setPrototypeOf ||\r\n        ({ __proto__: [] } instanceof Array && function (d, b) { d.__proto__ = b; }) ||\r\n        function (d, b) { for (var p in b) if (b.hasOwnProperty(p)) d[p] = b[p]; };\r\n    return extendStatics(d, b);\r\n};\r\n\r\nfunction __extends(d, b) {\r\n    extendStatics(d, b);\r\n    function __() { this.constructor = d; }\r\n    d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());\r\n}\n\n// Copyright (c) Facebook, Inc. and its affiliates. All Rights Reserved\r\n// From https://github.com/reduxjs/react-redux/blob/3e53ff96ed10f71c21346f08823e503df724db35/src/utils/shallowEqual.js\r\nvar hasOwn = Object.prototype.hasOwnProperty;\r\nfunction is(x, y) {\r\n    if (x === y) {\r\n        return x !== 0 || y !== 0 || 1 / x === 1 / y;\r\n    }\r\n    else {\r\n        return x !== x && y !== y;\r\n    }\r\n}\r\nfunction shallowEqual(objA, objB) {\r\n    if (is(objA, objB)) {\r\n        return true;\r\n    }\r\n    if (typeof objA !== 'object' ||\r\n        objA === null ||\r\n        typeof objB !== 'object' ||\r\n        objB === null) {\r\n        return false;\r\n    }\r\n    var keysA = Object.keys(objA);\r\n    var keysB = Object.keys(objB);\r\n    if (keysA.length !== keysB.length) {\r\n        return false;\r\n    }\r\n    // tslint:disable-next-line:prefer-for-of\r\n    for (var i = 0; i < keysA.length; i++) {\r\n        if (!hasOwn.call(objB, keysA[i]) || !is(objA[keysA[i]], objB[keysA[i]])) {\r\n            return false;\r\n        }\r\n    }\r\n    return true;\r\n}\n\n// Copyright (c) Facebook, Inc. and its affiliates. All Rights Reserved\r\n// React currently throws a warning when using useLayoutEffect on the server.\r\n// To get around it, we can conditionally useEffect on the server (no-op) and\r\n// useLayoutEffect in the browser.\r\nvar useIsomorphicLayoutEffect = typeof window !== 'undefined' ? useLayoutEffect : useEffect;\r\nvar MissingProviderError = /** @class */ (function (_super) {\r\n    __extends(MissingProviderError, _super);\r\n    function MissingProviderError() {\r\n        return _super.call(this, 'redux-react-hook requires your Redux store to be passed through ' +\r\n            'context via the <StoreContext.Provider>') || this;\r\n    }\r\n    return MissingProviderError;\r\n}(Error));\r\nfunction memoizeSingleArg(fn) {\r\n    var value;\r\n    var prevArg;\r\n    return function (arg) {\r\n        if (prevArg !== arg) {\r\n            prevArg = arg;\r\n            value = fn(arg);\r\n        }\r\n        return value;\r\n    };\r\n}\r\n/**\r\n * To use redux-react-hook with stronger type safety, or to use with multiple\r\n * stores in the same app, create() your own instance and re-export the returned\r\n * functions.\r\n */\r\nfunction create() {\r\n    var StoreContext = createContext(null);\r\n    /**\r\n     * Your passed in mapState function should be memoized with useCallback to avoid\r\n     * resubscribing every render. If you don't use other props in mapState, pass\r\n     * an empty array [] as the dependency list so the callback isn't recreated\r\n     * every render.\r\n     *\r\n     * const todo = useMappedState(useCallback(\r\n     *   state => state.todos.get(id),\r\n     *   [id],\r\n     * ));\r\n     */\r\n    function useMappedState(mapState) {\r\n        var store = useContext(StoreContext);\r\n        if (!store) {\r\n            throw new MissingProviderError();\r\n        }\r\n        // We don't keep the derived state but call mapState on every render with current state.\r\n        // This approach guarantees that useMappedState returns up-to-date derived state.\r\n        // Since mapState can be expensive and must be a pure function of state we memoize it.\r\n        var memoizedMapState = useMemo(function () { return memoizeSingleArg(mapState); }, [\r\n            mapState,\r\n        ]);\r\n        var state = store.getState();\r\n        var derivedState = memoizedMapState(state);\r\n        // Since we don't keep the derived state we still need to trigger\r\n        // an update when derived state changes.\r\n        var _a = useState(0), forceUpdate = _a[1];\r\n        // Keep previously commited derived state in a ref. Compare it to the new\r\n        // one when an action is dispatched and call forceUpdate if they are different.\r\n        var lastStateRef = useRef(derivedState);\r\n        var memoizedMapStateRef = useRef(memoizedMapState);\r\n        // We use useLayoutEffect to render once if we have multiple useMappedState.\r\n        // We need to update lastStateRef synchronously after rendering component,\r\n        // With useEffect we would have:\r\n        // 1) dispatch action\r\n        // 2) call subscription cb in useMappedState1, call forceUpdate\r\n        // 3) rerender component\r\n        // 4) call useMappedState1 and useMappedState2 code\r\n        // 5) calc new derivedState in useMappedState2, schedule updating lastStateRef, return new state, render component\r\n        // 6) call subscription cb in useMappedState2, check if lastStateRef !== newDerivedState, call forceUpdate, rerender.\r\n        // 7) update lastStateRef - it's too late, we already made one unnecessary render\r\n        useIsomorphicLayoutEffect(function () {\r\n            lastStateRef.current = derivedState;\r\n            memoizedMapStateRef.current = memoizedMapState;\r\n        });\r\n        useIsomorphicLayoutEffect(function () {\r\n            var didUnsubscribe = false;\r\n            // Run the mapState callback and if the result has changed, make the\r\n            // component re-render with the new state.\r\n            var checkForUpdates = function () {\r\n                if (didUnsubscribe) {\r\n                    // Don't run stale listeners.\r\n                    // Redux doesn't guarantee unsubscriptions happen until next dispatch.\r\n                    return;\r\n                }\r\n                var newDerivedState = memoizedMapStateRef.current(store.getState());\r\n                if (!shallowEqual(newDerivedState, lastStateRef.current)) {\r\n                    forceUpdate(increment);\r\n                }\r\n            };\r\n            // Pull data from the store after first render in case the store has\r\n            // changed since we began.\r\n            checkForUpdates();\r\n            // Subscribe to the store to be notified of subsequent changes.\r\n            var unsubscribe = store.subscribe(checkForUpdates);\r\n            // The return value of useEffect will be called when unmounting, so\r\n            // we use it to unsubscribe from the store.\r\n            return function () {\r\n                didUnsubscribe = true;\r\n                unsubscribe();\r\n            };\r\n        }, [store]);\r\n        return derivedState;\r\n    }\r\n    function useDispatch() {\r\n        var store = useContext(StoreContext);\r\n        if (!store) {\r\n            throw new MissingProviderError();\r\n        }\r\n        return store.dispatch;\r\n    }\r\n    return {\r\n        StoreContext: StoreContext,\r\n        useDispatch: useDispatch,\r\n        useMappedState: useMappedState,\r\n    };\r\n}\r\nfunction increment(x) {\r\n    return x + 1;\r\n}\n\n// Copyright (c) Facebook, Inc. and its affiliates. All Rights Reserved\r\nvar _a;\r\nvar StoreContext = (_a = create(), _a.StoreContext), useDispatch = _a.useDispatch, useMappedState = _a.useMappedState;\n\nexport { StoreContext, create, useDispatch, useMappedState };\n//# sourceMappingURL=index.es.js.map\n","/**\n * Mollie       https://www.mollie.nl\n *\n * @author      Mollie B.V. <info@mollie.nl>\n * @copyright   Mollie B.V.\n * @link        https://github.com/mollie/PrestaShop\n * @license     https://github.com/mollie/PrestaShop/blob/master/LICENSE.md\n * @codingStandardsIgnoreStart\n */\nimport React, { ReactElement } from 'react';\nimport styled, { keyframes } from 'styled-components';\n\nconst BounceAnimation = keyframes`\n  0% { margin-bottom: 0; }\n  50% { margin-bottom: 15px }\n  100% { margin-bottom: 0 }\n` as any;\n\nconst DotWrapper = styled.div`\n  display: flex;\n  align-items: flex-end;\n  min-height: 30px;\n` as any;\n\ninterface IDotProps {\n  delay: string;\n}\n\nconst Dot = styled.div`\n  background-color: black;\n  border-radius: 50%;\n  width: 10px;\n  height: 10px;\n  margin: 0 5px;\n  opacity: 0.7;\n  /* Animation */\n  animation: ${BounceAnimation} 0.5s linear infinite;\n  animation-delay: ${(props: IDotProps) => props.delay};\n` as any;\n\nfunction LoadingDots(): ReactElement<{}> {\n  return (\n    <DotWrapper>\n      <Dot delay=\"0s\" />\n      <Dot delay=\".1s\" />\n      <Dot delay=\".2s\" />\n    </DotWrapper>\n  );\n}\n\nexport default LoadingDots;\n"],"sourceRoot":""}